---
title: "How to use this package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use this package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(knitr)

knit_print.data.frame = function(x, ...) {
  res <- paste(c("", "", knitr::kable(x)), collapse = "\n")
  knitr::asis_output(res)
}

registerS3method(
  "knit_print", "data.frame", knit_print.data.frame,
  envir <- asNamespace("knitr")
)

library(dplyr)
```

```{r setup}
library(idaifieldR)
```

```{r echo = FALSE}
idaifield_test_docs <- readRDS(system.file("testdata",
                                           "idaifield_test_docs.RDS",
                                           package = "idaifieldR"))
# info for reference: The RDS is stored in its nested version, so:
idaifield_test_docs <- unnest_resource(idaifield_test_docs)
```

The package includes test data as an RDS file in `inst/testdata`, for the purpose of building this vignette. A backup with the same data that can be imported in i.DAIfield 2 is included as well, for reference. Since it is impossible to use the actual database connection when building this vignette, data is loaded from this file, but corresponds to what can be obtained with the `get_idaifield_docs()` function:

```{r eval=FALSE}
idaifield_test_docs <- get_idaifield_docs(
  # The IP listet in the i.DAIfield 2-Client as "Eigene Adresse":
  serverip = "192.168.1.21",
  # You can but should typically not need to specify the port, as the
  # default value is already i.DAIfield 2's default:
  port = 3000,
  # Name of the Project from said client that should be imported:
  projectname = "rtest",
  # Username to be used. This is inconsequential, as long as you are not
  # planning on writing anything to the db, which would be possible with sofa,
  # and may be useful in some cases!
  user = "R",
  # The password as listed in the i.DAIfield 2-client
  pwd = "hallo",
  # simplified = TRUE (which is the default) returns a list that is already
  # unnested to resource level. With simplified = FALSE it is possible to
  # obtain all the meta-info on each resource, i.e. the changelog of each
  # resource.
  simplified = TRUE
  )
```

This returns an object of class "idaifield_resources", which is a nested list: 

```{r}
idaifield_test_docs[[1]]
```

Since the format returned is very unwieldy, it can be somewhat simplified with `simplify_idaifield()`:

```{r}
idaifield_test_resources <- simplify_idaifield(idaifield_docs = idaifield_test_docs)
idaifield_test_resources[[1]]
```

This automatically unnests the list to its resource level (if not done so before) and reduces needless nesting.

With `get_uid_list()`, it is possible to generate a reference or "lookup"-table, that is (currently) needed to display the relationships between resources in a readable format, and can also be used to select single resources more easily. The indices of this table correspond to the numbering of resource-lists in the idaifield_docs or idaifield_resources object it was generated from: 

```{r}
uidlist <- get_uid_list(idaifield_test_docs)

uidlist %>%
  head()
```

It can also incorporate the shortDescription if one wishes, as that may be a bit more readable in some cases:

```{r}
idaifield_test_docs %>%
  get_uid_list(verbose = TRUE) %>%
  head()
```

For any further processing and especially larger data sets, the `select_by_type()` function should be important:

```{r}
layers <- select_by_type(idaifield_test_resources, type = "Layer")
layers[[5]]
```

A list of all resource-types present in the database can be gathered with `show_type_list()`. Only the internal names are referenced as types, and translations that you may see in the GUI can be different from these. They can be gathered in the i.DAIfield 2-Client from "Hilfe > Formularkonfiguration" (pink names in upper right corner).

```{r}
show_type_list(idaifield_test_docs)
```

A selection of the whole list can be converted into a matrix of lists: 

```{r}
pottery <- idaifield_test_resources %>%
  select_by_type(type = "Pottery") %>%
  idaifield_as_matrix()

pottery[1:5, 1:5]
```
(There is a function for data.frame conversion which pastes all entries from fields with multiple entries together, but I do not recommend it and frankly it might not even work anymore, as I have changes many things.)

With this matrix, it is easy to plot any distributions or actually further select and analyse the data. The matric can be coerced to a data.frame that will be easier for handling plotting functions.

```{r warning=FALSE}
pottery_df <- pottery %>%
  as.data.frame() %>%
  mutate(relation.liesWithin = as.character(relation.liesWithin))
head(pottery_df[,c(1, 25:29)])
```

And from the resulting data.frame, plotting with ggplot works without complications:

```{r fig.width=7}
library(ggplot2)

ggplot(pottery_df, aes(x = relation.liesWithin)) +
  geom_bar()
```
Though it may be required to reformat columns from list to character or factor:

```{r fig.width=7}
pottery_df$materialType <- as.character(pottery_df$materialType)

ggplot(pottery_df, aes(x = relation.liesWithin, fill = materialType)) +
  geom_bar()
```

