---
title: "How to use this package: Essential Workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{essentials}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

`idaifieldR` is able to import the database from an iDAI.field Client into R in a format that is easily usable with basic R functionality. 

```{r setup}
library(idaifieldR)
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
idaifield_test_docs <- readRDS(system.file("testdata",
                                           "idaifield_test_docs.RDS",
                                           package = "idaifieldR"))
# info for reference: The RDS is stored in its nested version, so:
all_resources <- check_and_unnest(idaifield_test_docs)
```

After loading the package, you first need to establish a connection to the database. This will only work if the Client is running. This is done with a connection object that is produced by `connect_idaifield()`: 

```{r eval=FALSE}
connection <- connect_idaifield(serverip = "127.0.0.1",
                                user = "R",
                                pwd = "hallo")
```

If you wish to import the complete database into R, you can use `get_idaifield_docs()` with the default options. Be aware that this can take **a long time** depending on the size of your database. Just to give you an impressing: I regularly work with ca. 4000 resources, and the import takes roughly 20 seconds while the resulting `idaifield_resources`-object is around 20MB in size.

```{r eval=FALSE}
all_resources <- get_idaifield_docs(connection = connection, 
                                    projectname = "rtest",
                                    raw = FALSE)
```

This will return a list that still resembles the original JSON-format of Fields database:
```{r eval=TRUE}
all_resources[[1]]
```

Additionally, using the object that contains all resources, you can generate an index of the database which is handy for some other functions or to get a general impression of what is there:
```{r eval=TRUE}
uidlist <- get_uid_list(all_resources, verbose = TRUE, gather_trenches = TRUE)
head(uidlist)
```

To make the list more usable and to fix the values of fields that may otherwise display UIDs (as relations are stored this way in the database), you can use the function `simplify_idaifield()`. Depending on the size of you database it may take a while to process. You can decide whether you want to replace the UIDs with their corresponding identifiers, and whether you want to use the geometry attached to each resource.

```{r eval=TRUE}
all_resources <- simplify_idaifield(all_resources, 
                                    keep_geometry = FALSE, 
                                    replace_uids = TRUE)
all_resources[[1]]
```

`idaifieldR` contains a custom function to convert the list returned by the import functions `simplify_idaifield()`, `idf_query()` and `idf_index_query()` into a matrix. For your convenience, you should probably convert this into a data.frame and try to assign the column type automatically: 
```{r eval=TRUE}
all_resources <- idaifield_as_matrix(all_resources)
df <- as.data.frame(all_resources)
df <- type.convert(df, as.is = TRUE)
str(df[,1:10])
```

# Queries 
If the import of all resources takes too long, it is possible to query the database: 
```{r eval=TRUE, echo=FALSE, message = FALSE, warning=FALSE}
pottery <- select_by(idaifield_test_docs, by = "type", value = "Pottery")
pottery <- simplify_idaifield(pottery, 
                              keep_geometry = FALSE, 
                              replace_uids = TRUE, 
                              uidlist = uidlist)
```

```{r eval=FALSE}
pottery <- idf_query(connection, projectname = "rtest", 
                     field = "type", 
                     value = "Pottery",
                     uidlist = uidlist)
```
```{r eval=TRUE}
pottery <- idaifield_as_matrix(pottery)
pottery_df <- as.data.frame(pottery)
pottery_df <- type.convert(pottery_df, as.is = TRUE)
head(pottery_df[,1:10])
```

However, that functionality is currently very limited. If you need more sophisticated queries, you can take a look at the documentation of the `sofa` package, which allows complex queries. The results can again be transformed with some functions from `idaifieldR`.

# Plotting

Getting the data into R allows you to flexible create plots and analysis, that can be re-run when more data is available in the Field-Database or at another time. 

Some very basic examples:

```{r fig.width=7}
library(ggplot2)
pottery <- as.data.frame(pottery)
ggplot(pottery, aes(x = relation.liesWithin)) +
  geom_bar()
```


```{r fig.width=7}
ggplot(pottery, aes(x = specificType)) +
  geom_bar()
```
```{r fig.width=7}
ggplot(pottery, aes(x = condition)) +
  geom_bar()
```
You can do this with basically anthing that is in the database. Some variables may need reformating and cleaning, depending on your configuration and the state of the data. 
