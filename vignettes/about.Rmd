---
title: "About this package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use this package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(knitr)

knit_print.data.frame <- function(x, ...) {
  res <- paste(c("", "", knitr::kable(x)), collapse = "\n")
  knitr::asis_output(res)
}

registerS3method(
  "knit_print", "data.frame", knit_print.data.frame,
  envir <- asNamespace("knitr")
)

library(dplyr)
```

```{r setup}
library(idaifieldR)
```

```{r echo = FALSE}
idaifield_test_docs <- readRDS(system.file("testdata",
                                           "idaifield_test_docs.RDS",
                                           package = "idaifieldR"))
# info for reference: The RDS is stored in its nested version, so:
idaifield_test_resources <- simplify_idaifield(idaifield_test_docs)
```

The package includes test data as an RDS file in `inst/testdata`, for the purpose of building this vignette. A backup with the same data that can be imported in iDAI.field 2 / Field Desktop is included as well, for reference. Since it is impossible to use the actual database connection when building this vignette, data is loaded from this file, but corresponds to what can be obtained with the `get_idaifield_docs()` function.

When importing data your first step would be to build a connection object, where **serverip** corresponds to the IP listed in the Field Client as "*Eigene Adresse*" when using the client in a network, **user** can be anything you wish and will only be important if you intend to write to the database, as the client does not employ user-specific passwords. **pwd** should be the password as listed in the Field Client. If you run the Client on the same computer as you R-Script, you can use the localhost address (*127.0.0.1*).



```{r eval=FALSE}
connection <- connect_idaifield(serverip = "127.0.0.1",
                                user = "R",
                                pwd = "hallo")
```

*Note*: The default options are set for Field Desktop (iDAI.field 3). If you continue to use iDAI.field 2, you need to add the version number to `connect_idaifield()`, otherwise the connection cannot be established!

```{r eval=FALSE}
connection <- connect_idaifield(serverip = "127.0.0.1",
                                user = "R",
                                pwd = "hallo",
                                version = 2)
```


Sofa can help you get a list of all the projects that are stored in the database:

```{r eval=FALSE}
sofa::db_list(connection)
```

# Getting your DB-Entries into R 

The project database you are using can either be imported in total (see below), or queried. The functions demonstrated here are wrapping the queries possible with `sofa` in other functions as to make it more accessible to people using iDAI.field 2 / Field Desktop. If you want more complex queries, I suggest to use sofa directly.

For almost any function of this package, you will need a "uidlist". It serves as an index to the database and as a way of replacing UIDs with their respective identifiers for readability. You can obtain this uidlist / the index as follows:

```{r eval=FALSE}
all_resources <- get_idaifield_docs(
  connection = connection,
  projectname = "rtest",
  simplified = TRUE
)
uidlist <- get_uid_list(all_resources)
```

With the `idf_query()`-function, you can then query the database with some of the fields and variables. This will not work for everything: e.g. relations cannot be queried in this way. 

```{r eval = FALSE}
layers <- idf_query(connection = connection, 
                    uidlist = uidlist,
                    project = "rtest", 
                    field = "type", 
                    value = "Layer")
```

Another example, this time querying for "Farbe" in the radioButton field "distinguishingCriteria":

```{r eval = FALSE}
layers <- idf_query(connection = connection, 
                    uidlist = uidlist,
                    project = "rtest", 
                    field = "distinguishingCriteria", 
                    value = "Farbe")
```

However, these queries will only work for fields that cannot have more than one value (i.e. radio Buttons, Dropdown lists, names). With Sofa, searching for Regular Expressions etc. is possible. If you intend to do that, I would recommend to use sofa directly. 




# The Inefficient Way (deprecated functions)

The following explanations and functions will no longer be used after a complete re-structuring of this package. However, I am leaving them here as to not ruin the day of any person that may have used this at some point. 

And `get_idaifield_docs()` imports all documents from the project. `simplified = TRUE` (which is the default) returns a list that is already unnested to resource level. With simplified = FALSE it is possible to obtain all the meta-info on each resource, i.e. the changelog of each resource.

```{r eval=FALSE}
idaifield_test_resources <- get_idaifield_docs(
  connection = connection,
  projectname = "rtest",
  simplified = TRUE
  )
```

This returns an object of class "idaifield_resources", which is a nested list: 

```{r}
idaifield_test_resources[[1]]
```



For any further processing and especially larger data sets, the `select_by()` function should be important:

```{r}
layers <- select_by(idaifield_test_resources, by = "type", value = "Layer")
layers[[5]]
```

A list of all resource-types present in the database can be gathered with `show_type_list()`. Only the internal names are referenced as types, and translations that you may see in the GUI can be different from these. They can be gathered in the Field Client from "Hilfe \> Formularkonfiguration" (pink names in upper right corner).

```{r}
show_type_list(idaifield_test_resources)
```

A selection of the whole list can be converted into a matrix of lists: 

```{r}
pottery <- idaifield_test_resources %>%
  select_by(by = "type", value = "Pottery") %>%
  idaifield_as_matrix()

pottery[1:5, 1:5]
```
(There is a function for data.frame conversion which pastes all entries from fields with multiple entries together, but I do not recommend it and frankly it might not even work anymore, as I have changes many things.)

With this matrix, it is easy to plot any distributions or actually further select and analyse the data. The matric can be coerced to a data.frame that will be easier for handling plotting functions.

```{r warning=FALSE}
library(dplyr)
pottery_df <- pottery %>%
  as.data.frame() %>%
  mutate_all(~ as.character(.))
head(pottery_df[, c(1, 25:29)])
```

And from the resulting data.frame, plotting with ggplot works without complications:

```{r fig.width=7}
library(ggplot2)

ggplot(pottery_df, aes(x = relation.liesWithin)) +
  geom_bar()
```
Though it may be required to reformat columns from list to character or factor:

```{r fig.width=7}
ggplot(pottery_df, aes(x = relation.liesWithin, fill = materialType)) +
  geom_bar()
```


# Notes

If you are planing on using the coordinates from the geometry in iDAI.field 2 / Field Desktop, 
I strongly suggest you modify your digit length in R before importing. Depending 
on the projection used in the database, the import might omit some digits or 
or round numbers. 

Example: 

```{r eval = FALSE}
options(digits = 20)
```

# Geometry

As a comment: `simplify_idaifield()` or `get_idaifield_docs(..., simplified = TRUE)` by default reformats the geometry entries so that the coordinates are stored in a matrix. This can be reformatted with the `sp`-package to display in R-leaflet maps etc. (You will still need to add the CRS.) The geometry-matrix has 3 columns for x, y and z values. If there are only two-dimensional data in the database, height will be set to 0.

# Alternatives

In case you wish to work with the whole database in json-format, I suggest you use the jsonlite package which has similar capabilities to e.g. flatten any lists and output. You can get the whole database in json format via: 

```{r eval = FALSE}
connection <- connect_idaifield(serverip = "127.0.0.1", 
                                user = "R",
                                pwd = "hallo")
json_output <- get_idaifield_docs(projectname = "rtest",
                                  connection = connection,
                                  json = TRUE)
library(jsonlite)
nested_df <- fromJSON(json_output)$rows
flattened_df <- flatten(nested_df)
```

Since I prepared this package mostly to suit my own need you might be happier with this output. Most functions from this package however will probably not work with the flattened/converted json-outputs, but it should not be hard to find replace the UIDs etc, for which some internal functions in this package may still be useful.

# Other Notes

Since version 3 (Field Desktop / iDAI.field 3) the Configuration itself can be extracted from the database. You can possibly use this to incorporate translations into plots, though I have yet to figure out a way how. 

This will return a matrix with nested lists representing the whole project configuration: 

```{r eval = FALSE}
config <- get_idaifield_docs(connection = connection,
                             projectname = "rtest") %>% 
  select_by(by = "type", value = "Configuration") 
```
